// Generated by CoffeeScript 1.8.0
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

define(["three", "physi", "bunnies"], function(THREE, Physijs, bunnies) {
  return new ((function() {
    function _Class() {
      this.render = __bind(this.render, this);
      this.animate = __bind(this.animate, this);
    }

    _Class.prototype.size = function() {
      var height, width;
      height = window.innerHeight;
      width = window.innerWidth;
      this.renderer.setSize(width, height);
      this.height = this.renderer.domElement.height;
      return this.width = this.renderer.domElement.width;
    };

    _Class.prototype.init = function() {
      var bunny, candle, cover, floor, frog, i, lookingAtPoint, mazewall, orientationEvent, separation, shape, supportsOrientationChange, wall;
      Physijs.scripts.ammo = "../ammo.js/builds/ammo.js";
      Physijs.scripts.worker = "../bower_components/physijs/physijs_worker.js";
      this.scene = new Physijs.Scene({
        fixedTimeStep: 2 / 60
      });
      this.scene.setGravity(new THREE.Vector3(0, -100, 0));
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.size();
      supportsOrientationChange = __indexOf.call(window, 'onorientationchange') >= 0;
      orientationEvent = supportsOrientationChange ? 'orientationchange' : 'resize';
      window.addEventListener(orientationEvent, ((function(_this) {
        return function() {
          return _this.size();
        };
      })(this)), false);
      document.body.appendChild(this.renderer.domElement);
      this.smoothness = 60;
      this.keys = [];
      this.in3d = 1;
      separation = 10;
      this.cameras = new THREE.Object3D();
      lookingAtPoint = new THREE.Vector3(0, 0, -1000);
      this.scene.add(this.cameras);
      this.cameras.position.set(0, 0, 700);
      this.cameraLeft = new THREE.PerspectiveCamera(45, 1, 1, 4000);
      this.cameras.add(this.cameraLeft);
      this.cameraLeft.lookAt(lookingAtPoint);
      this.cameraLeft.position.set(-separation, 0, 0);
      this.cameraRight = new THREE.PerspectiveCamera(45, 1, 1, 4000);
      this.cameras.add(this.cameraRight);
      this.cameraRight.lookAt(lookingAtPoint);
      this.cameraRight.position.set(separation, 0, 0);
      shape = new THREE.PlaneGeometry(600, 400);
      cover = new THREE.MeshBasicMaterial();
      cover.color.setRGB(0.5, 0.5, 0.5);
      wall = new THREE.Mesh(shape, cover);
      this.scene.add(wall);
      wall.rotation.set(0, 0.5, 0);
      wall.receiveShadow = true;
      shape = new THREE.CubeGeometry(5000, 10, 5000);
      cover = new THREE.MeshBasicMaterial();
      cover.color.setRGB(0.8, 0.5, 0.3);
      floor = new Physijs.BoxMesh(shape, cover, 0);
      floor.position.set(0, -100, 0);
      this.scene.add(floor);
      shape = new THREE.CubeGeometry(500, 400, 50);
      cover = new THREE.MeshBasicMaterial();
      cover.color.setRGB(0.0, 1.0, 0.0);
      mazewall = new Physijs.BoxMesh(shape, cover);
      mazewall.position.set(0, 200, 0);
      this.scene.add(mazewall);
      this.ghost = new Ghost();
      this.scene.add(this.ghost.body);
      this.bunnies = [];
      i = 0;
      while (i < 1) {
        bunny = new Bunny();
        this.bunnies.push(bunny);
        bunny.body.position.set(500, 25, -200);
        this.scene.add(bunny.body);
        i++;
      }
      this.frogs = [];
      i = 0;
      while (i < 1) {
        frog = new Frog();
        this.frogs.push(frog);
        frog.body.position.set(-500, 25, 100);
        this.scene.add(frog.body);
        i++;
      }
      candle = new THREE.DirectionalLight();
      candle.intensity = 0.2;
      candle.position.set(0, -120, 300);
      this.scene.add(candle);
      candle.castShadow = true;
      this.scene.updateMatrixWorld(true);
      document.addEventListener("keydown", (function(_this) {
        return function(event) {
          var key;
          key = event.keyCode;
          _this.keys[key] = 1;
        };
      })(this));
      document.addEventListener("keyup", (function(_this) {
        return function(event) {
          var key;
          key = event.keyCode;
          _this.keys[key] = 0;
        };
      })(this));
      window.addEventListener('deviceorientation', ((function(_this) {
        return function(event) {
          var beta, forward, gamma, rotation, side, _base, _base1, _base2, _base3, _ref;
          _ref = _this.width < _this.height ? [event.beta, event.gamma] : (beta = -event.gamma, gamma = event.beta, Math.abs(gamma) > 90 ? beta = 180 - beta : void 0, [beta, gamma]), forward = _ref[0], side = _ref[1];
          rotation = (forward - 90) * 3.14 / 180;
          _this.cameras.rotation.x = rotation * Math.cos(_this.cameras.rotation.y);
          _this.cameras.rotation.z = rotation * Math.sin(_this.cameras.rotation.y);
          console.log("" + _this.cameras.rotation.x + "," + _this.cameras.rotation.z);
          (_base = _this.keys)[37] || (_base[37] = 0);
          (_base1 = _this.keys)[38] || (_base1[38] = 0);
          (_base2 = _this.keys)[39] || (_base2[39] = 0);
          (_base3 = _this.keys)[40] || (_base3[40] = 0);
          if (forward < -50) {
            _this.keys[40] += 1;
            _this.keys[38] = 0;
          } else if (forward > -10) {
            _this.keys[38] += 1;
            _this.keys[40] = 0;
          } else {
            _this.keys[38] = _this.keys[40] = 0;
          }
          if (side < -15) {
            _this.keys[37] += 1;
            return _this.keys[39] = 0;
          } else if (side > 15) {
            _this.keys[39] += 1;
            return _this.keys[37] = 0;
          } else {
            return _this.keys[37] = _this.keys[39] = 0;
          }
        };
      })(this)), true);
      return this.clock = new THREE.Clock();
    };

    _Class.prototype.pressed = function(key) {
      return key > 0 && key < 100;
    };

    _Class.prototype.animate = function() {
      var t;
      t = this.clock.getElapsedTime();
      this.ghost.animate(t);
      if (this.keys[87]) {
        this.bunnies[0].run(t, 0);
      }
      if (this.keys[65]) {
        this.bunnies[0].run(t, -1);
      }
      if (this.keys[68]) {
        this.bunnies[0].run(t, 1);
      }
      if (this.keys[89]) {
        this.frogs[0].run(t, 0);
      }
      if (this.keys[71]) {
        this.frogs[0].run(t, -1);
      }
      if (this.keys[74]) {
        this.frogs[0].run(t, 1);
      }
      this.bunnies.forEach((function(_this) {
        return function(bunny) {
          if (_this.keys[90]) {
            bunny.run(t, 0);
          }
          bunny.animate(t);
        };
      })(this));
      this.frogs.forEach((function(_this) {
        return function(frog) {
          if (_this.keys[90]) {
            frog.run(t, 0);
          }
          frog.animate(t);
        };
      })(this));
      return this.scene.simulate();
    };

    _Class.prototype.render = function() {
      var width;
      if (this.smoothness >= 60) {
        requestAnimationFrame(this.render);
      }
      if (this.in3d) {
        width = Math.round(this.width / 2);
        this.cameraLeft.aspect = width * this.in3d / this.height;
        this.cameraRight.aspect = width * this.in3d / this.height;
      } else {
        width = this.width;
        this.cameraLeft.aspect = width / this.height;
      }
      this.renderer.setViewport(0, 0, width, this.height);
      this.renderer.setScissor(0, 0, width, this.height);
      this.renderer.enableScissorTest(true);
      this.cameraLeft.updateProjectionMatrix();
      this.renderer.render(this.scene, this.cameraLeft);
      if (this.in3d) {
        this.renderer.setViewport(width, 0, width, this.height);
        this.renderer.setScissor(width, 0, width, this.height);
        this.renderer.enableScissorTest(true);
        this.cameraRight.updateProjectionMatrix();
        return this.renderer.render(this.scene, this.cameraRight);
      }
    };

    _Class.prototype.runSimulation = function() {
      if (this.smoothness >= 60) {
        this.render();
      } else {
        setInterval(this.render, 1000 / this.smoothness);
      }
      return setInterval(this.animate, 50);
    };

    return _Class;

  })());
});
